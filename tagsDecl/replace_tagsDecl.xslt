<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- replace_tagsDecl.xslt -->
<!-- Read in a TEI P5 document and write out the same document with -->
<!-- <tagsDecl> elements replaced by ones that reflect the current  -->
<!-- encoding.                                                      -->
<!-- Copyleft 2025 by Syd Bauman and the Women Writers Project. -->
<!-- Based very heavily on generate_tagsDecl.xslt (itself       -->
<!-- based heavily on James Cummings’ Count-Elements.xsl at     -->
<!-- http://wiki.tei-c.org/index.php/Count-Elements.xsl,        -->
<!-- 2009-07-06.                                                -->
<xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xpath-default-namespace="http://www.tei-c.org/ns/1.0"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns="http://www.tei-c.org/ns/1.0"
  exclude-result-prefixes="#all" >

  <!-- My version number: -->
  <xsl:variable name="version" select="'1.0.0'"/>
  
  <xsl:output method="xml" indent="no"/>
  <!--
      Usage note:
      The output would be a lot more readable if the @indent, above,
      were "yes". But this has the potential to insert whitespace that
      is not in the original that some folks might be unhappy with.
  -->
  <xsl:mode on-no-match="shallow-copy"/>
  
  <xsl:template match="/">
    <xsl:apply-templates select="child::node()" mode="topmost"/>
  </xsl:template>
  <!-- The templates above & below, combined, just try to make output prettier for humans. -->
  <xsl:template match="/node()" mode="topmost">
    <xsl:apply-templates select="." mode="#default"/>
    <xsl:text>&#x0A;</xsl:text>
  </xsl:template>

  <!-- If we hit the <encodingDesc> and there is no <appInfo>, add one. -->
  <xsl:template match="encodingDesc[ not( appInfo )]">
    <xsl:copy>
      <xsl:apply-templates select="@*"/>
      <xsl:text>&#x0A;</xsl:text>
      <appInfo>
        <xsl:text>&#x0A;</xsl:text>
        <xsl:call-template name="generate_application_information"/>
      </appInfo>
      <xsl:apply-templates select="node()"/>
    </xsl:copy>
  </xsl:template>

  <!-- If we hit the first <appInfo>, add our <application> at the top -->
  <xsl:template match="appInfo[ not( preceding-sibling::appIfno ) ]">
    <!-- copy over the <appInfo>:  -->
    <xsl:copy>
      <!-- get its attributes: -->
      <xsl:apply-templates select="@*"/>
      <!-- get any nodes *before* the 1st <application>: -->
      <xsl:apply-templates select="node()[ not( self::application | preceding-sibling::application ) ]"/>
      <!-- generate our <appliation>: -->
      <xsl:call-template name="generate_application_information"/>
      <!-- get any existing <application> elements and other nodes that occur *after* last <application>:  -->
      <xsl:apply-templates select="node()[      self::application | preceding-sibling::application   ]"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template name="generate_application_information">
    <!-- get current timestamp in UTC: -->
    <xsl:variable name="dT"  select="format-dateTime( current-dateTime(), '[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01][Z00:00t]')"/>
    <xsl:variable name="dTz" select="adjust-dateTime-to-timezone( $dT cast as xs:dateTime, xs:dayTimeDuration('-PT0H') )"/>
    <!-- insert <application>: -->
    <application ident="replace_tagsDecl" version="{$version}" when="{$dTz}" source="{static-base-uri()}">
      <!-- if the surrounding language is not English, flag this
           element as English because its content is in English. (As I
           do not speak any other languages well enough to write an
           application description.) -->
      <xsl:if test="not( lang('en') )">
        <xsl:attribute name="xml:lang" select="'en'"/>
      </xsl:if>
      <xsl:text>&#x0A;The tagging declaration(s) herein were generated by this program, the canonical source of which is on </xsl:text>
      <ref
      target="https://github.com/NEU-DSG/wwp-public-code-share/blob/main/tagsDecl/replace_tagsDecl.xslt">gitHub</ref>
      <xsl:text>.&#x0A;</xsl:text>
    </application>
    <xsl:text>&#x0A;</xsl:text>
  </xsl:template>
  
  <!-- When we hit the 1st <tagsDecl>, process each associated <text>
       element into a <tagsDecl>. -->
  <xsl:template match="tagsDecl[ not( preceding-sibling::tagsDecl )]">
    <!-- Since the <tagsDecl> talks about the elements “occurring within the -->
    <!-- outermost <text> element of a TEI document”, we only want to match the -->
    <!-- outermost <text> element(s), i.e. children of the same <TEI> that -->
    <!-- contains this <tagsDecl>, regardless of how deeply nested within -->
    <!-- <teiCorpus> or <TEI> elements this <TEI> is. -->
    <xsl:apply-templates select="../../../text" mode="createTagsDecl"/>
  </xsl:template>
  <!-- When we hit the 2nd or later <tagsDecl>, summarily ignore it,
       as we have just generated all the <tagsDecl>s we need. -->
  <xsl:template match="tagsDecl[ preceding-sibling::tagsDecl ]"/>

  <!-- From each associated input <text> arises a <tagsDecl> -->
  <xsl:template match="text" mode="createTagsDecl">
    <xsl:variable name="me" select="."/>
    <tagsDecl partial="false">
      <!-- Use @n to indicate from which <text> this <tagsDecl> was generated. -->
      <xsl:attribute name="n">
        <xsl:choose>
          <xsl:when test="@xml:id"><xsl:sequence select="'for_'||@xml:id"/></xsl:when>
          <xsl:when test="count( ../text ) eq 1">for_the_first_and_only_text_element</xsl:when>
          <xsl:otherwise>
            <xsl:variable name="num" select="format-integer( count( preceding::text ) +1, 'w;o')" as="xs:string"/>
            <xsl:sequence select="'for_the_'||$num||'_text_element'"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <!-- Get list of namespaces used by my descendant elements. -->
      <xsl:variable name="namespaces" select="distinct-values( $me//*!namespace-uri() )" as="xs:anyURI+"/>
      <!-- For each of those namespace URIs (in sorted order), … -->
      <xsl:for-each select="$namespaces">
        <xsl:sort/>
        <!-- … remember it for easy reference … -->
        <xsl:variable name="ns" select="."/>
        <!-- … and output a <namespace> element. -->
        <xsl:text>&#x0A;</xsl:text>
        <namespace name="{$ns}">
          <!-- Get list of the local names of my descendant elements. -->
          <xsl:variable name="gis" select="distinct-values( $me//*[ namespace-uri(.) eq $ns ]!local-name() )" as="xs:string+"/>
          <!-- For each of those local names (sorted by count) … -->
          <xsl:for-each select="$gis">
            <xsl:sort order="descending" select="count( $me//*[ namespace-uri(.) eq $ns  and  local-name(.) eq current() ] )"/>
            <!-- … remember it for easy reference … -->
            <xsl:variable name="gi" select="."/>
            <!-- … and output a <tagUsage> element with appropriate attributes. -->
            <tagUsage gi="{.}"
                      occurs="{format-integer( count( $me//*[ namespace-uri(.) eq $ns  and  local-name(.) eq $gi ] ),            '000')}"
                      withId="{format-integer( count( $me//*[ namespace-uri(.) eq $ns  and  local-name(.) eq $gi ][ @xml:id ] ), '000')}"/>
          </xsl:for-each>
          <xsl:text>&#x0A;</xsl:text>
        </namespace>
      </xsl:for-each>
      <xsl:text>&#x0A;</xsl:text>
    </tagsDecl>
  </xsl:template>
  
</xsl:stylesheet>
